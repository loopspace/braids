% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
braids --- a style file for drawing braid diagrams with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines some commands for drawing braid diagrams with TikZ/PGF.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
braids --- a style file for drawing braid diagrams with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011 by Andrew Stacey <stacey@math.ntnu.no>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the file  braids.dtx
and the derived files           braids.ins,
                                braids.pdf, and
                                braids.sty.

\endpostamble
\usedir{tex/latex/braids}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/braids}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*package>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{braids}[2011/05/07 v1.0 Tikz/PGF commands for drawing braid diagrams]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{\jobname}
\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{breakatwhitespace=true,breaklines=true,language=TeX}
 
\usepackage{fancyvrb}

\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{braids.sty}
% \title{The \textsf{braids} package: codebase}
% \author{Andrew Stacey \\ \url{stacey@math.ntnu.no}}
% \date{\fileversion~from \filedate}
% 
% \maketitle
% 
% \begin{center}
% \begin{tikzpicture}
% \braid[line width=3pt,line cap=round,style strand={1}{blue},number of strands=7] s_1 s_2 s_5^{-1};
% \end{tikzpicture}
% \end{center}
% 
% \section{Introduction}
% 
% This is a package for drawing braid diagrams using PGF/TikZ.
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
%
% Test the version of PGF to see if it's what we expect.
% \begin{macrocode}
\def\braid@pgfversion{2.10}%
\ifx\pgfversion\braid@pgfversion
\else
\PackageWarning{braids}{This package was designed using PGF2.10; you are using \pgfversion.}%
\fi
% \end{macrocode}%
% \begin{macro}{\ge@addto@macro}
% This is an expanded version of \Verb+\g@addto@macro+.
% Namely, it adds the \emph{expansion} of the second argument to the first.
%    \begin{macrocode}
\long\def\ge@addto@macro#1#2{%
  \begingroup
  \toks@\expandafter\expandafter\expandafter{\expandafter#1#2}%
  \xdef#1{\the\toks@}%
  \endgroup}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\braid}
% This is the user command.
% We start a group to ensure that all our assignments are local, and then call our initialisation code
%    \begin{macrocode}
\newcommand{\braid}[1][]{%
  \begingroup
  \braid@start{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@process}
% This is the token swallower.
% This takes the next token on the braid specification and passes it to the handler command which decides what to do next.
%    \begin{macrocode}
\def\braid@process{%
  \afterassignment\braid@handle\let\braid@token=%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@process@start}
% This is a variant of \Verb+\braid@process+ which is used at the start where we might have a few extra bits and pieces before the braid itself starts.
%    \begin{macrocode}
\def\braid@process@start{%
  \afterassignment\braid@handle@start\let\braid@token=%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\braid@handle@start}
% This is the handler in use at the start.
% It looks for the tokens \Verb+a+ or \Verb+(+ which (might) signal the start of an \Verb+at (coordinate)+ or \Verb+(name)+.
% If we get anything else (modulo spaces) we decide that we've reached the end of the initialisation stuff and it is time to get started on the braid itself.
%    \begin{macrocode}
\def\braid@handle@start{%
  \let\braid@next=\braid@handle
  \ifx\braid@token a
   \let\braid@next=\braid@maybe@locate
  \else
  \ifx\braid@token(%)
   \iffalse)\fi %Indentation hack!
   \let\braid@next=\braid@assign@name
  \else
  \ifx\braid@token\@sptoken
   \let\braid@next=\braid@process@start
  \fi
  \fi
  \fi
  \braid@next%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@handle}
% This is the main handler for parsing the braid word.
% It decides what action to take depending on what the token is.
% We have to be a bit careful with catcodes, some packages set
% ; and | to be active.
%    \begin{macrocode}
\let\braid@semicolon=;
\let\braid@bar=|
\def\braid@handle{%
  \let\braid@next=\braid@process
  \ifnum\the\catcode`\;=\active
  \expandafter\let\expandafter\braid@semicolon\tikz@activesemicolon
  \fi
  \ifnum\the\catcode`\|=\active
  \expandafter\let\expandafter\braid@bar\tikz@activebar
  \fi
  \ifx\braid@token\braid@semicolon
   \let\braid@next=\braid@render
  \else
  \ifx\braid@token^
   \let\braid@next=\braid@sup
  \else
  \ifx\braid@token_
   \let\braid@next=\braid@sub
  \else
  \ifx\braid@token-
   \braid@increase@levelfalse
  \else
  \ifx\braid@token[
   \let\braid@next=\braid@process@options
  \else
  \ifx\braid@token\braid@bar
   \edef\braid@tmp{,\expandafter\the\value{braid@level}}%
   \ge@addto@macro\braid@floors\braid@tmp%
  \else
  \ifx\braid@token\bgroup
   \braid@beginscope
  \else
  \ifx\braid@token\egroup
   \braid@endscope
  \else
  \ge@addto@macro\braid@label{\braid@token}%
  \fi
  \fi
  \fi
  \fi
  \fi
  \fi
  \fi
  \fi
  \braid@next%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@maybe@locate}
% If we got an \Verb+a+ token in the \Verb+\braid@handle@start+ then it \emph{might} mean we're looking at \Verb+at (coordinate)+ or it might mean that the user has decided to use \Verb+a+ as the braid parameter.
% So we examine the next token for a \Verb+t+. 
%    \begin{macrocode}
\def\braid@maybe@locate{%
  \afterassignment\braid@@maybe@locate\let\braid@token=%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@@maybe@locate}
% This is where we test for \Verb+t+ and act appropriately.
%    \begin{macrocode}
\def\braid@@maybe@locate{%
  \let\braid@next=\braid@handle
  \ifx\braid@token t
   \let\braid@next=\braid@find@location
  \fi
  \braid@next%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@find@location}
% This macro starts us looking for a coordinate.
%    \begin{macrocode}
\def\braid@find@location{%
  \afterassignment\braid@@find@location\let\braid@token=%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@@find@location}
% This is the test for the start of a coordinate.
% If we get a \Verb+(+ that means we've reached the coordinate.
% A space means ``carry on''.
% Anything else is a (non-fatal) error.
%    \begin{macrocode}
\def\braid@@find@location{%
  \let\braid@next=\braid@location@error
  \ifx\braid@token(%)
   \let\braid@next=\braid@locate
  \else
  \ifx\braid@token\@sptoken
   \let\braid@next=\braid@find@location
  \fi
  \fi
  \braid@next%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@location@error}
% This is our error message for not getting an error
%    \begin{macrocode}
\def\braid@location@error{%
  \PackageWarning{braids}{Could not figure out location for braid}%
  \braid@process@start%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@locate}
% If we reached a \Verb+(+ when looking for a coordinate, everything up to the next \Verb+)+ is that coordinate.
%    \begin{macrocode}
\def\braid@locate#1){%
  \braid@relocate{(#1)}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@relocate}
% This is the macro that actually does the relocation.
%    \begin{macrocode}
\def\braid@relocate#1{%
  \tikz@scan@one@point\braid@@relocate#1}
\def\braid@@relocate#1{%
  #1
  \advance\pgf@x by -\braid@width
  \pgftransformshift{\pgfqpoint{\pgf@x}{\pgf@y}}
  \braid@process@start%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@assign@name}
% This macro saves our name.
%    \begin{macrocode}
\def\braid@assign@name#1){%
  \def\braid@name{#1}%
  \braid@process@start%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@process@options}
% The intention of this macro is to allow setting of style options mid-braid.
% (At present, this wouldn't make a lot of sense.)
%    \begin{macrocode}
\def\braid@process@options#1]{%
    \tikzset{#1}%
  \braid@process%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@sup}
% This handles braid elements of the form \Verb+a^{-1}_2+.
%    \begin{macrocode}
\def\braid@sup#1_#2{\g@addto@macro\braid@label{_{#2}^{#1}}\braid@add@crossing{#2}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@sub}
%    \begin{macrocode}
% This handles braid elements of the form \Verb+a_1+ or \Verb+a_1^{-1}+.
\def\braid@sub#1{\@ifnextchar^{\braid@@sub{#1}}{\g@addto@macro\braid@label{_{#1}}\braid@add@crossing{#1}{1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@@sub}
% Helper macro for \Verb+\braid@sub+.
%    \begin{macrocode}
\def\braid@@sub#1^#2{\g@addto@macro\braid@label{_{#1}^{#2}}\braid@add@crossing{#1}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@ne}
% Remember what \Verb+1+ looks like for testing against.
%    \begin{macrocode}
\def\braid@ne{1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@add@crossing}
% This is the macro which add the crossing to the current list of strands.
% The strands are stored as \emph{soft paths} (see the TikZ/PGF documentation).
% So this selects the right strands and then extends them according to the crossing type.
%    \begin{macrocode}
\def\braid@add@crossing#1#2{%
  \edef\braid@crossing@type{#2}
  \edef\braid@this@strand{#1}
  \pgfmathtruncatemacro{\braid@next@strand}{#1+1}

% increment the counter, if requested
  \ifbraid@increase@level
  \stepcounter{braid@level}
  \fi
% request increment next time
  \braid@increase@leveltrue

% Coordinates of crossing
  \braid@tx=\braid@this@strand\braid@width
  \braid@ty=\value{braid@level}\braid@height
  \advance\braid@ty by \braid@eh
  \braid@nx=\braid@tx
  \braid@ny=\braid@ty
  \advance\braid@nx by \braid@width
  \advance\braid@ny by \braid@height
  \braid@cy=\braid@ty
  \braid@dy=\braid@ny
  \advance\braid@cy by .5\braid@height
  \advance\braid@dy by -.5\braid@height
  \advance\braid@ty by .05\braid@height
  \advance\braid@ny by -.05\braid@height

% Try to find a starting point for the strand ending here
  \expandafter\let\expandafter\braid@this@path@origin\csname braid@strand@\braid@this@strand @origin\endcsname

\ifx\braid@this@path@origin\relax
  % Haven't seen this strand before, so initialise it
  % Record the initial position of the strand
  \let\braid@this@path@origin\braid@this@strand
  % start a new soft path
  \pgfsyssoftpath@setcurrentpath{\@empty}
  \pgfpathmoveto{\pgfpoint{\braid@tx}{0pt}}
  % save the path
  \pgfsyssoftpath@getcurrentpath{\braid@this@path}
  \else
  \expandafter\let\expandafter\braid@this@path\csname braid@strand@\braid@this@path@origin\endcsname
  \fi

% Try to find a starting point for the next strand ending here
  \expandafter\let\expandafter\braid@next@path@origin\csname braid@strand@\braid@next@strand @origin\endcsname

  \ifx\braid@next@path@origin\relax
  % Haven't seen this strand before, so initialise it
  % Record the initial position of the strand
  \let\braid@next@path@origin\braid@next@strand
  % start a new soft path
  \pgfsyssoftpath@setcurrentpath{\@empty}
  \pgfpathmoveto{\pgfpoint{\braid@nx}{0pt}}
  % save the path
  \pgfsyssoftpath@getcurrentpath{\braid@next@path}
  \else
  \expandafter\let\expandafter\braid@next@path\csname braid@strand@\braid@next@path@origin\endcsname
  \fi

  % Start with the first path
  \pgfsyssoftpath@setcurrentpath{\braid@this@path}
  % Draw a line down to the current level
  \pgfpathlineto{\pgfqpoint{\braid@tx}{\braid@ty}}
  % Curve across to the next position
\ifx\braid@crossing@type\braid@over@cross
\pgfpathcurveto{\pgfqpoint{\braid@tx}{\braid@cy}}{\pgfqpoint{\braid@nx}{\braid@dy}}{\pgfqpoint{\braid@nx}{\braid@ny}}
\else
\pgfpathcurvebetweentimecontinue{0}{.4}{\pgfqpoint{\braid@tx}{\braid@ty}}{\pgfqpoint{\braid@tx}{\braid@cy}}{\pgfqpoint{\braid@nx}{\braid@dy}}{\pgfqpoint{\braid@nx}{\braid@ny}}
\pgfpathcurvebetweentime{.6}{1}{\pgfqpoint{\braid@tx}{\braid@ty}}{\pgfqpoint{\braid@tx}{\braid@cy}}{\pgfqpoint{\braid@nx}{\braid@dy}}{\pgfqpoint{\braid@nx}{\braid@ny}}
\fi
    % Save the path
  \pgfsyssoftpath@getcurrentpath{\braid@this@path}

  % Now do the same with the second path
  \pgfsyssoftpath@setcurrentpath{\braid@next@path}
  % Draw a line down to the current level
  \pgfpathlineto{\pgfqpoint{\braid@nx}{\braid@ty}}
  % Curve across to the previous position
\ifx\braid@crossing@type\braid@over@cross
\pgfpathcurvebetweentimecontinue{0}{.4}{\pgfqpoint{\braid@nx}{\braid@ty}}{\pgfqpoint{\braid@nx}{\braid@cy}}{\pgfqpoint{\braid@tx}{\braid@dy}}{\pgfqpoint{\braid@tx}{\braid@ny}}
\pgfpathcurvebetweentime{.6}{1}{\pgfqpoint{\braid@nx}{\braid@ty}}{\pgfqpoint{\braid@nx}{\braid@cy}}{\pgfqpoint{\braid@tx}{\braid@dy}}{\pgfqpoint{\braid@tx}{\braid@ny}}
\else
  \pgfpathcurveto{\pgfqpoint{\braid@nx}{\braid@cy}}{\pgfqpoint{\braid@tx}{\braid@dy}}{\pgfqpoint{\braid@tx}{\braid@ny}}
\fi
  % Save the path
  \pgfsyssoftpath@getcurrentpath{\braid@next@path}

% Now save the paths again
  \expandafter\let\csname braid@strand@\braid@this@path@origin \endcsname\braid@this@path
  \expandafter\let\csname braid@strand@\braid@next@path@origin \endcsname\braid@next@path

  % Now update the origins
  \expandafter\let\csname braid@strand@\braid@this@strand @origin\endcsname\braid@next@path@origin
  \expandafter\let\csname braid@strand@\braid@next@strand @origin\endcsname\braid@this@path@origin

% increment the strand counter, if necessary
  \pgfmathparse{\value{braid@strands} < \braid@next@strand ? "\noexpand\setcounter{braid@strands}{\braid@next@strand}" : ""}
  \pgfmathresult
  \braid@process%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@floors@trim}
% The list of floors, if given, will start with a superfluous comma.
% This removes it.
%    \begin{macrocode}
\def\braid@floors@trim,{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@render@floor}
% This is the default render for floors: it draws a rectangle.
%    \begin{macrocode}
\def\braid@render@floor{%
    \draw (\floorsx,\floorsy) rectangle (\floorex,\floorey);
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@render}
% This is called at the end of the braid and it renders the braids and floors according to whatever has been built up up to now.
%    \begin{macrocode}
\def\braid@render{
    \ifx\braid@floors\@empty
    \else
    \pgfsys@beginscope
    \pgfsyssoftpath@setcurrentpath{\empty}
    \edef\braid@floors{\expandafter\braid@floors@trim\braid@floors}
    \braid@tx=\braid@width
    \advance\braid@tx by \braid@eh
    \braid@nx=\value{braid@strands}\braid@width
    \advance\braid@nx by -\braid@eh
    \foreach \braid@f in \braid@floors {
      \pgfsys@beginscope
      \braid@ty=\braid@f\braid@height
      \advance\braid@ty by \braid@eh
      \advance\braid@ty by \braid@height
      \braid@ny=\braid@ty
      \advance\braid@ny by \braid@height
      \edef\floorsx{\the\braid@tx}
      \edef\floorsy{\the\braid@ty}
      \edef\floorex{\the\braid@nx}
      \edef\floorey{\the\braid@ny}
      \let\tikz@options=\pgfutil@empty
% Load general floor style options
    \expandafter\tikzset\expandafter{\braid@floors@style}
% Load any style options specific to this floor
      \pgfmathtruncatemacro{\braid@ff}{\braid@f+2}
    \expandafter\let\expandafter\braid@floor@style\csname braid@options@floor@\braid@ff\endcsname
    \ifx\braid@floor@style\relax
    \else
    \expandafter\tikzset\expandafter{\braid@floor@style}
    \fi
\tikz@options
\braid@render@floor
\pgfsys@endscope
    }
    \pgfsys@endscope
    \fi
  \stepcounter{braid@level}
  \foreach \braid@k in {1,...,\value{braid@strands}} {
% Start a local scope to ensure we don't mess with other braids
    \pgfsys@beginscope
% Default is to draw each braid
    \tikz@mode@drawtrue%
    \let\tikz@mode=\pgfutil@empty
    \let\tikz@options=\pgfutil@empty
% (x,y) coordinates of bottom of strand
    \braid@tx=\braid@k\braid@width
    \braid@ty=\value{braid@level}\braid@height
    \advance\braid@ty by 2\braid@eh
% Try to find the starting point of this strand
    \expandafter\let\expandafter\braid@path@origin\csname braid@strand@\braid@k @origin\endcsname
    \ifx\braid@path@origin\relax
% If that doesn't exist, we'll just draw a straight line
% so we move to the top of the current position
    \pgfsyssoftpath@setcurrentpath{\@empty}
    \pgfpathmoveto{\pgfqpoint{\braid@tx}{0pt}}
    \let\braid@path@origin\braid@k
    \else
% If the path does exist, we load it
    \expandafter\let\expandafter\braid@path\csname braid@strand@\braid@path@origin\endcsname
    \pgfsyssoftpath@setcurrentpath{\braid@path}
    \fi
% Extend the path to the bottom
    \pgflineto{\pgfqpoint{\braid@tx}{\braid@ty}}
% Load common style options
    \expandafter\tikzset\expandafter{\braid@style}
% Load any style options specific to this strand
    \expandafter\let\expandafter\braid@style\csname braid@options@strand@\braid@path@origin\endcsname
    \ifx\braid@style\relax
    \else
    \expandafter\tikzset\expandafter{\braid@style}
    \fi
\braid@options
    \tikz@mode
    \tikz@options
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
\ifx\braid@name\pgfutil@empty
\else
% label the ends of the strand
\coordinate (\braid@name-\braid@path@origin-e) at (\braid@tx,\braid@ty);
\coordinate (\braid@name-rev-\braid@k-e) at (\braid@tx,\braid@ty);
\braid@nx=\braid@path@origin\braid@width
\coordinate (\braid@name-\braid@path@origin-s) at (\braid@nx,0pt);
\coordinate (\braid@name-rev-\braid@k-s) at (\braid@nx,0pt);
\fi
% Close the scope
   \pgfsys@endscope
  }
    \ifx\braid@name\pgfutil@empty
    \else
    \braid@tx=\value{braid@strands}\braid@width
    \braid@ty=\value{braid@level}\braid@height
    \advance\braid@ty by 2\braid@eh
    \advance\braid@tx by \braid@width
    \braid@tx=.5\braid@tx
    \braid@ty=.5\braid@ty
    \coordinate (\braid@name) at (\braid@tx,\braid@ty);
    \fi
    \pgfsys@endscope
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\braid@start}
% This starts off the braid, initialising a load of stuff.
%    \begin{macrocode}
\def\braid@start#1{%
      \pgfsys@beginscope
      \setcounter{braid@level}{-1}%
      \let\braid@label\@empty
      \let\braid@floors\@empty
      \let\braid@name\empty
      \pgfkeys{/pgf/braid/.cd,#1}
      \let\braid@options\tikz@options
  \tikz@transform
      \setcounter{braid@strands}{\pgfkeysvalueof{/pgf/braid/number of           strands}}%
    \braid@width=\pgfkeysvalueof{/pgf/braid/width}
    \braid@height=\pgfkeysvalueof{/pgf/braid/height}
    \braid@eh=\pgfkeysvalueof{/pgf/braid/border height}
    \braid@height=-\braid@height
    \braid@eh=-\braid@eh
    \braid@increase@leveltrue
    \braid@process@start
}
%    \end{macrocode}
% \end{macro}
%
% These are the lengths we'll use as we construct the braid
%    \begin{macrocode}
\newdimen\braid@width
\newdimen\braid@height
\newdimen\braid@tx
\newdimen\braid@ty
\newdimen\braid@nx
\newdimen\braid@ny
\newdimen\braid@cy
\newdimen\braid@dy
\newdimen\braid@eh
%    \end{macrocode}
%
% An if to decide whether or not to step to the next level or not
%    \begin{macrocode}
\newif\ifbraid@increase@level
%    \end{macrocode}
%
% Some initial values
%    \begin{macrocode}
\let\braid@style\pgfutil@empty
\let\braid@floors@style\pgfutil@empty
\def\braid@over@cross{1}
%    \end{macrocode}
%
% Counters to track the strands and the levels.
%    \begin{macrocode}
\newcounter{braid@level}
\newcounter{braid@strands}
%    \end{macrocode}
%
% All the keys we'll use.
%    \begin{macrocode}
\pgfkeys{
    /tikz/braid/.search also={/pgf},
    /pgf/braid/.search also={/pgf,/tikz},
    /pgf/braid/.cd,
    number of strands/.initial=0,
    height/.initial=1cm,
    width/.initial=1cm,
    border height/.initial=.25cm,
    name/.code={%
      \def\braid@name{#1}%
    },
    at/.code={%
      \braid@relocate{#1}%
    },
    floor command/.code={%
      \def\braid@render@floor{#1}%
    },
    style strand/.code 2 args={%
      \expandafter\def\csname braid@options@strand@#1\endcsname{#2}
    },
    style floor/.code 2 args={%
      \expandafter\def\csname braid@options@floor@#1\endcsname{#2}
    },
    style floors/.code={%
      \def\braid@floors@style{#1}
    }
}
%    \end{macrocode}
% \iffalse
%</package>
% \fi
%
% \Finale

\endinput
